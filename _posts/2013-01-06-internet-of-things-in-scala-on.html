---
layout: post
title: Internet of Things in Scala on Raspberry Pi
date: '2013-01-06T19:46:00.001-05:00'
author: Leonid Dubinsky
tags:
- electronics
- scala
modified_time: '2013-04-15T01:22:18.322-04:00'
blogger_id: tag:blogger.com,1999:blog-8681083740214020499.post-8876003498529001840
blogger_orig_url: https://blog.dub.podval.org/2013/01/internet-of-things-in-scala-on.html
---

<span style="font-family: Arial, Helvetica, sans-serif;">I want to connect things like LEDs, buttons, displays, sensors, relays etc. to a computer&nbsp;(<a href="http://en.wikipedia.org/wiki/Physical_computing">physical computing</a>). I want to program that computer in&nbsp;<a href="http://www.scala-lang.org/">Scala</a>. And I want to connect to the Internet (<a href="http://en.wikipedia.org/wiki/Internet_of_Things">Internet of Things</a>). I chose&nbsp;<a href="http://www.raspberrypi.org/">Raspberry Pi</a>&nbsp;as the platform.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> <span style="font-family: Arial, Helvetica, sans-serif;">This post details the ways to connect things, the platform choices, and the programming interfaces.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> <span style="font-family: Arial, Helvetica, sans-serif;">I also wrote some Scala code. The code is very rough:</span><span style="font-family: Arial, Helvetica, sans-serif;">&nbsp;I spend around three days (during a winter break of 2012) researching and developing it, but specific things that I needed to work (I2C) already work.&nbsp;</span><span style="font-family: Arial, Helvetica, sans-serif;">In the spirit of "</span><a href="http://en.wikipedia.org/wiki/Release_early,_release_often" style="font-family: Arial, Helvetica, sans-serif;">release early, release often</a><span style="font-family: Arial, Helvetica, sans-serif;">", I decided to announce it anyway.&nbsp;</span><span style="font-family: Arial, Helvetica, sans-serif;">The project is hosted on</span><span style="font-family: Arial, Helvetica, sans-serif;">&nbsp;</span><a href="https://github.com/" style="font-family: Arial, Helvetica, sans-serif;">GitHub</a><span style="font-family: Arial, Helvetica, sans-serif;">:</span><span style="font-family: Arial, Helvetica, sans-serif;">&nbsp;</span><a href="https://github.com/dubinsky/podval-iot" style="font-family: Arial, Helvetica, sans-serif;">podval-iot</a><span style="font-family: Arial, Helvetica, sans-serif;">.</span><br />
<br />
<div><span style="font-family: Arial, Helvetica, sans-serif;">I hate&nbsp;</span><a href="http://en.wikipedia.org/wiki/Java_Native_Interface" style="font-family: Arial, Helvetica, sans-serif;">JNI</a><span style="font-family: Arial, Helvetica, sans-serif;">&nbsp;with its "</span><a href="http://stackoverflow.com/a/65237" style="font-family: Arial, Helvetica, sans-serif;">crashing is the default mode of operation</a><span style="font-family: Arial, Helvetica, sans-serif;">"; the only native interface that I can tolerate is&nbsp;</span><a href="https://github.com/twall/jna" style="font-family: Arial, Helvetica, sans-serif;">JNA</a><span style="font-family: Arial, Helvetica, sans-serif;">.</span></div><span style="font-family: Arial, Helvetica, sans-serif;"><span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> I prefer to use standard Linux facilities wherever available, and avoid hardware-specific code, non-standard libraries and bit-banging. The result should be usable on platforms other than Raspberry Pi.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span><span style="font-family: Arial, Helvetica, sans-serif;">I do not focus on the <a href="http://www.codecommit.com/blog/java/interop-between-java-and-scala">Scala/Java interoperability</a>, so it may be difficult to use my library from Java.&nbsp;My rationale for allowing myself to go with Scala is</span><br />
<ul><li><span style="font-family: Arial, Helvetica, sans-serif;">the binding may be cleaner using Scala features</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">people who are not ready to switch to Scala can use existing Java bindings</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">for some availability of a library they need in Scala may be the last push to switch over - I would be thankful now if such a push happened to me few years back ;)</span></li>
</ul><a name='more'></a><h2><span style="font-family: Arial, Helvetica, sans-serif;">How to Connect Things to Computers</span></h2><div><span style="font-family: Arial, Helvetica, sans-serif;"><a href="http://en.wikipedia.org/wiki/Physical_computing">Physical computing</a> requires connecting devices (sensors, displays, relays etc.) to a computer or a programmable controller. It is done through <a href="http://en.wikipedia.org/wiki/General_Purpose_Input/Output">GPIO</a> (General Purpose Input/Output) pins.</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;">The level of a given pin can be set in software to high or low (digital output). This is sufficient to control LEDs and other low-current devices. If more current is needed than a GPIO pin can handle, a transistor can be used. To control high-voltage devices, a relay is called for.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> <span style="font-family: Arial, Helvetica, sans-serif;">The level of a pin can be read in software</span><span style="font-family: Arial, Helvetica, sans-serif;">&nbsp;(digital input). This is sufficient to connect buttons and switches, but requires polling, making it computationally unfeasible. Often, it is possible to configure&nbsp;</span><span style="font-family: Arial, Helvetica, sans-serif;">interrupts to be triggered by changes in the pin levels.</span><br />
<br />
<span style="font-family: Arial, Helvetica, sans-serif;">There may be configurable <a href="http://en.wikipedia.org/wiki/Pull-up_resistor">pull-up/pull-down resistors</a>&nbsp;on the pins.</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span></div><div><div><span style="font-family: Arial, Helvetica, sans-serif;">By pulsing the output level of a pin with pulses of controlled width,&nbsp;<i>average</i>&nbsp;level of the pin can be controlled without a DAC -&nbsp;<a href="http://en.wikipedia.org/wiki/Pulse-width_modulation">Pulse-Width Modulation</a>&nbsp;(PWM).</span></div><div></div><span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> <span style="font-family: Arial, Helvetica, sans-serif;">A pin can have <a href="http://en.wikipedia.org/wiki/Analog-to-digital_converter">analog-to-digital converter</a> (ADC), so a level on the pin can be read with more precision than just high or low (analog input). If there is a <a href="http://en.wikipedia.org/wiki/Digital-to-analog_converter">digital-to-analog converter</a> (DAC) on the pin, its level can be set more precisely than just high or low (analog output).</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;">This hardware GPIO functionality is exposed to software through I/O registers.</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;">There are many protocols for connecting devices to (a set of) GPIO pins:</span></div><div><ul><li><span style="font-family: Arial, Helvetica, sans-serif;"><a href="http://en.wikipedia.org/wiki/I2C">I2C</a>/<a href="http://en.wikipedia.org/wiki/SMBus">SMBus</a>&nbsp;- two-wire interface for attaching low-speed peripherals</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;"><a href="http://en.wikipedia.org/wiki/SPI_bus">SPI bus</a> - four-wire full-duplex high-speed serial bus</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;"><a href="http://en.wikipedia.org/wiki/1-Wire">1-Wire</a>: one-wire low-speed interface for attaching sensors and such</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">Serial (<a href="http://en.wikipedia.org/wiki/Uart">UART</a>):&nbsp;for connecting to other boards (<a href="http://en.wikipedia.org/wiki/Microcontrollers">microcontrollers</a>, <a href="http://en.wikipedia.org/wiki/Zigbee">ZigBee</a> radios etc.)</span></li>
</ul></div><div><span style="font-family: Arial, Helvetica, sans-serif;">PWM, I2C, SMB, SPI, Serial and 1-Wire can be done in software, using basic GPIO digital input/output capabilities (<a href="http://en.wikipedia.org/wiki/Bit-banging">bit banging</a>). This is computationally expensive, especially if polling of the pins is involved, so&nbsp;on a platform that is not fast enough,&nbsp;software-based implementation of such protocols is not feasible. Also, the protocols are timing-sensitive</span><span style="font-family: Arial, Helvetica, sans-serif;">, so on a platform that is not real-time it can be difficult.</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;">Often, some of the protocols are implemented in hardware of the underlying microcontroller or <a href="http://en.wikipedia.org/wiki/System_on_chip">System on a Chip</a> (SoC), and exposed to software through the same mechanism as the basic GPIO functionality itself.</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;">Some protocols can be implemented in external hardware that is accessed through one of the natively-implemented protocols. For instance, computationally-intensive 1-Wire protocol can be offloaded to a chip like&nbsp;<a href="http://www.maximintegrated.com/datasheet/index.mvp/id/4382">DS2482-100</a>&nbsp;that communicates to the host system over I2c.</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;">Missing ADC or DAC capabilities can be added through the use of external chips: &nbsp;SPI ADC chip <a href="http://www.microchip.com/wwwproducts/Devices.aspx?dDocName=en010530">MCP3008</a> ($<a href="https://www.adafruit.com/products/856">3.75</a>), I2C ADC&nbsp;breakout board&nbsp;<a href="http://www.ti.com/product/ads1015">ADS1015</a> ($<a href="https://www.adafruit.com/products/1083">10</a>), I2C DAC&nbsp;breakout board&nbsp;<a href="http://www.microchip.com/wwwproducts/Devices.aspx?dDocName=en532229">MCP4725</a> &nbsp;($<a href="https://www.adafruit.com/products/935">5</a>). External ADC/DAC is often more precise than the built-in ones, and sometimes more feature-rich (ADS1015 has <a href="http://en.wikipedia.org/wiki/Programmable-gain_amplifier">programmable-gain amplifiers</a>).</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;">External chips can also be used to obtain additional GPIO pins - for instance, an I2C I/O expanders like <a href="http://www.microchip.com/wwwproducts/Devices.aspx?dDocName=en021393">MCP23008</a>&nbsp;($<a href="https://www.adafruit.com/products/593">2</a>).</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span></div><h2><span style="font-family: Arial, Helvetica, sans-serif;">What I Want to Connect</span></h2><span style="font-family: Arial, Helvetica, sans-serif;">Suppose I want to build, for my daughter's room something that can:</span><br />
<ul><li><span style="font-family: Arial, Helvetica, sans-serif;">work as an alarm clock</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">measure temperature and humidity</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">display the measurements locally and</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">graph the measurements on&nbsp;<a href="https://cosm.com/">Cosm</a></span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">play some music as a wake-up alarm</span></li>
</ul><div><span style="font-family: Arial, Helvetica, sans-serif;">Simple temperature sensor like TMP36 ($<a href="https://www.adafruit.com/products/165">2</a>) neead an "analog in" pin to connect to, which Raspberry Pi does not have. This is easy to remedy with - say - a SPI MCP3008; see, for example, this&nbsp;<a href="http://learn.adafruit.com/send-raspberry-pi-data-to-cosm">tutorial</a>. Alternatively, I2C TMP102 ($<a href="https://www.sparkfun.com/products/9418">6</a>) can be used.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;">Combined temperature/humidity sensors do not use analog interface at all. For instance:</span></div><div><ul><li><span style="font-family: Arial, Helvetica, sans-serif;">DHT11 ($<a href="https://www.adafruit.com/products/386">5</a>) and DHT22 ($<a href="https://www.adafruit.com/products/385">12.50</a>) have - it seems - 1-Wire interface;</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">SHT11 ($<a href="https://www.adafruit.com/products/246">35</a>) uses,&nbsp;<a href="http://forums.electricimp.com/discussion/comment/2076#Comment_2051">according</a>&nbsp;to Hugo of the Electric Imp, "nearly like, but not actually I2C";</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">SHT21 ($<a href="http://www.liquidware.com/shop/show/SEN-SHT/Humidity+and+Temperature+Sensor">40</a>) uses I2c.</span></li>
</ul><span style="font-family: Arial, Helvetica, sans-serif;">I am not ready to deal with the tricky timing of the 1-Wire protocol myself, and SHT sensors seem to be more advanced anyway. I do not want to bit-bang "something like I2C", so I picked SHT21 as my sensor over SHT11, as Hugo recommended.</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span></div><div><div><span style="font-family: Arial, Helvetica, sans-serif;">For the display of time and sensor data I picked nice and bright four-digit seven-segment LED displays from Adafruit ($</span><a href="https://www.adafruit.com/products/880" style="font-family: Arial, Helvetica, sans-serif;">10</a><span style="font-family: Arial, Helvetica, sans-serif;">). They have I2C interface, so only four wires need to be connected for each. Up to 4 can be attached to the same I2C bus.</span></div><span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> <span style="font-family: Arial, Helvetica, sans-serif;">For general-purpose interaction with the system, an I2C-based LCD display with buttons ($<a href="https://www.adafruit.com/products/1110">25</a>) seems to be the way to go.</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;">Should I need to blink some LEDs or switch on the light, GPIO will come handy - or I can use an I2C expander like MCP23008. That would mean wasting the existing GPIO pins, though, and I am not clear on the support for the interrupts generated by the expander...</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> <br />
<div><span style="font-family: Arial, Helvetica, sans-serif;">Although I do not need 1-Wire support for this project, I wouldn't mind having it for another project for a friend from&nbsp;<a href="http://www.lechemlab.com/">LechemLabs</a>:&nbsp;I need to use a bunch of temperature sensors (to measure temperature inside rising dough), and the best ones (like&nbsp;<a href="http://adafruit.com/products/381">DS18B20</a>) talk 1-Wire protocol. Actually, that sensor seems to be the main reason people use 1-Wire :)</span></div><span style="font-family: Arial, Helvetica, sans-serif;"><span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> It seems that I2C is just about sufficient for my current needs.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;"><i>[Aside: I2C.</i>&nbsp;Since I2C is so convenient, and is present in every computer, the question is - why isn't it available everywhere? Well, probably because it does not pay to provide additional connector on every machine - a connector that only a tiny minority of buyers will use. How about a USB-to-I2C dongle, then? Every computer has USB! And here it is:&nbsp;<a href="http://thingm.com/products/linkm.html">LimkM</a>&nbsp;($<a href="https://www.sparkfun.com/products/9903">30</a>).&nbsp;So, if I only wanted to connect some hardware to a real computer, this is a possibility. The dongle does not expose the I2C bus in a standard Linux way, though: it would need to have a kernel module to do that...]</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span></div><h2><span style="font-family: Arial, Helvetica, sans-serif;">Internet of Things Platforms</span></h2><span style="font-family: Arial, Helvetica, sans-serif;">Here are some of the hardware platforms that can be used for the Internet of Things projects.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> <h3><span style="font-family: Arial, Helvetica, sans-serif;">Arduino</span></h3><span style="font-family: Arial, Helvetica, sans-serif;">A while ago, when I wanted to connect some sensors and such to a computer, I became aware of <a href="http://blog.dub.podval.org/2010/05/arduino.html">Arduino</a>&nbsp;- a programmable microcontroller board with GPIO pins.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
Arduino Internet connectivity is not cost-efficient.&nbsp;Arduino Uno board costs $<a href="https://www.adafruit.com/products/50">30</a>.&nbsp;Ethernet&nbsp;shield&nbsp;for Arduino costs $<a href="https://www.sparkfun.com/products/9026">45</a>.&nbsp;WiFi&nbsp;shield&nbsp;costs $<a href="https://www.sparkfun.com/products/11287">85</a>! A ZigBee&nbsp;radio&nbsp;is $<a href="https://www.sparkfun.com/products/8665">23</a> (without adaptor board), and requires a gateway for the Internet connection. Compare to Raspberry Pi Model B with built-in Ethernet port for $35 or Raspberry Pi Model A ($25) with WiFi dongle ($12)...</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
Maybe things are a bit better with Arduino Due ($<a href="https://www.adafruit.com/products/1076">50</a>), since it has a USB port, but I am not sure.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> <h3><span style="font-family: Arial, Helvetica, sans-serif;">Electric Imp</span></h3><span style="font-family: Arial, Helvetica, sans-serif;">Recently, another platform became available - <a href="http://electricimp.com/">Electric Imp</a>.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
Allegedly,&nbsp;<a href="http://www.linkedin.com/pub/hugo-fiennes/0/3a3/110">Hugo Fiennes</a>, CEO of Electric Imp,&nbsp;was frustrated when he wanted to connect a programmable LED strip to the Internet. This frustration brought us the Electric Imp. &nbsp;(Previously, Hugo was frustrated that he does not have all his music in his car - and built a first in-dash MP3 player -&nbsp;<a href="http://www.empeg.com/">empeg</a>, which I still have in my car :))</span><br />
<div><span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span></div><span style="font-family: Arial, Helvetica, sans-serif;">This amazing device costs $<a href="https://www.sparkfun.com/products/11395">30</a> (development board is $<a href="https://www.adafruit.com/products/1130">12.50</a>), has a microcontroller, GPIO pins, ADC, I2C. There is no 1-Wire support, and Imp is too slow to do it in software, but&nbsp;Hugo <a href="http://forums.electricimp.com/discussion/comment/1592#Comment_1592">promised</a> 1-Wire support done in firmware early in 2013 (that just started).</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
Electric Imp has&nbsp;built-in WiFi.&nbsp;Not only is it possible to connect it to the Internet, it is <i>impossible</i>&nbsp;to program it in any other way: a <a href="http://www.squirrel-lang.org/">Squirrel</a> program is compiled in the cloud and downloaded to the Imp over WiFi!</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
Hugo says that Imp-based sensor that reports a reading once an hour can work off batteries for more than two years - and still use&nbsp;ubiquitous&nbsp;WiFi and not - contrary to the industry wisdom - ZigBee!</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> <h3><span style="font-family: Arial, Helvetica, sans-serif;">Raspberry Pi</span></h3><span style="font-family: Arial, Helvetica, sans-serif;">The board costs $<a href="http://www.mcmelectronics.com/product/83-14421">35</a> with Ethernet port and 2 USB ports or $25 with no Ethernet and 1 USB port. It has an ARM CPU, 512MB of RAM, GPU capable of full HD, HDMI connector, audio out, camera connector, GPIO pins, I2C, SPI, PWM, UART. There is no built-in ADC.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> <span style="font-family: Arial, Helvetica, sans-serif;">There is no built-in WiFi, but because it has USB ports, WiFi is just a $<a href="https://www.adafruit.com/products/814">12</a> dongle away.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
It runs a flavor of Debian Linux and is thus very flexible. For instance, even for projects where real time is needed, one does not need the Real Time Clock module ($<a href="https://www.adafruit.com/products/255">17.50</a>) - <a href="http://www.eecis.udel.edu/~mills/ntp/html/ntpd.html">NTP daemon</a> takes care of clock synchronization :)</span><br />
<div><br />
</div><span style="font-family: Arial, Helvetica, sans-serif;">One argument against a Linux-running board and for a microcontroller is: Linux is not a&nbsp;<a href="http://en.wikipedia.org/wiki/Real-time_operating_system">real-time OS</a>. Also, languages like Scala and Java (and even Python, the favorite of the Raspberry Pi community) do garbage collection at unpredictable times (I suspect that Squirrel that Electrical Imp uses does the same). But - you get multi-threading :)</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
Some say that it is an <a href="http://news.ycombinator.com/item?id=4138045">overkill</a> to use Raspberry Pi where you can use a simple microcontroller. Yes, it will consume more power, but if it is in a room with an electrical outlet, this is not an issue.&nbsp;Maybe it is just the thought of all those unused CPU cycles and peripherals (like HDMI in a project that does not use it) that makes people feel it is an overkill....</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> <div><h3><span style="font-family: Arial, Helvetica, sans-serif;">Other</span></h3></div><span style="font-family: Arial, Helvetica, sans-serif;">There are other platforms out there: <a href="http://beagleboard.org/bone">BeagleBone</a>, <a href="http://www.indiegogo.com/pinoccio">Pinoccio</a>, etc. And I am sure there will be more still :)</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> <h2><span style="font-family: Arial, Helvetica, sans-serif;">Choosing a Platform</span></h2><span style="font-family: Arial, Helvetica, sans-serif;">Choice of a platform for a particular project is guided by requirements for:</span><br />
<ul><li><span style="font-family: Arial, Helvetica, sans-serif;">power consumption</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">connectivity</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">computing power</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;">flexibility</span></li>
</ul><span style="font-family: Arial, Helvetica, sans-serif;">A nice comparison of Arduino Uno, BeagleBone and Raspberry Pi is available at&nbsp;<a href="http://digitaldiner.blogspot.com/2012/10/arduino-uno-vs-beaglebone-vs-raspberry.html">Digital Diner</a>.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
For portable, stand-alone devices&nbsp;(like the photo trigger I did not built yet :))&nbsp;Arduino&nbsp;is probably the best: Electric Imp is likely not powerful enough, and Raspberry Pi is too power-hungry (although&nbsp;people do use it in portable projects).</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
For embedded connected sensors and such, Electric imp&nbsp;Imp is probably better than Arduino: Imp's built-in connectivity is more price-effective. If more computational power is needed, Arduino with Zigbee is an option. Stand-alone data-logging sensors are easier with an Arduino.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;">For multimedia and home entertainment centers Raspberry Pi is probably ideal: Electric Imp is not powerful enough for video, and Arduino requires additional hardware that itself costs more than a Raspberry Pi. And power consumption is not an issue.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
Actually, for any project where power consumption is not an issue, I'd lean towards Raspberry Pi, because&nbsp;my language of choice is Scala. I do not want to program Arduino in a C++ dialect, nor Imp in Squirrel.&nbsp;Raspberry Pi is an affordable platform that allows me - theoretically - to participate in the Internet of Things using my language of choice.&nbsp;It is not powerful enough to actually run a Java/Scala IDE, but as long as the versions of the libraries are the same, code compiled elsewhere runs fine.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;">Yes, Linux is not a real-time OS. But you know what? I'll take a pleasant development experience working in a strongly typed language with functional programming support in a real IDE, even if in the end the clock display will sometimes miss an update and then jump ahead two seconds.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;">Libraries written for Raspberry Pi tend to be in Python or C. I do not want to write in use Python or C; I want to write in Scala. I can call into Java libraries from Scala, but I can not call into Python. I can call into C using JNI, but that requires writing in C, and I do not want that. Besides, I hate JNI.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
Thus, to make using Scala practical, I need a native Scala binding to the facilities that I need, using - at most - JNA.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> <h2><span style="font-family: Arial, Helvetica, sans-serif;">Raspberry Pi Peripherals and Linux</span></h2><div><span style="font-family: Arial, Helvetica, sans-serif;">The bare-metal way to get at all the peripherals of Raspberry Pi is through the memory-mapped I/O registers.&nbsp;Official Broadcom <a href="http://www.raspberrypi.org/wp-content/uploads/2012/02/BCM2835-ARM-Peripherals.pdf">documentation</a>&nbsp;explains all the registers of the&nbsp;BCM2835 (this is the chip inside Raspberry Pi; BCM2708 seems to be the name of the family of which BCM2835 is a member).</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span><br />
<div><span style="font-family: Arial, Helvetica, sans-serif;">An overview of various methods of getting at the peripherals is in the "<a href="http://elinux.org/RPi_Low-level_peripherals">RPi Low-level peripherals</a>" tutorial.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
It is possible to write a userspace library that uses I/O registers to provide a reasonable interface to some of the GPIO functionality:</span><br />
<ul><li><span style="font-family: Arial, Helvetica, sans-serif;">Python library&nbsp;<a href="http://pypi.python.org/pypi/RPi.GPIO">RPi.GPIO</a>. Supports GPIO. Support for I2C, SPI, PWM, UART, and 1-Wire is planned.</span></li>
<li><span style="font-family: Arial, Helvetica, sans-serif;"><a href="http://www.open.com.au/mikem/bcm2835/">BCM2835</a>&nbsp;library. Supports GPIO and SPI.</span></li>
</ul></div><span style="font-family: Arial, Helvetica, sans-serif;">Linux-standard&nbsp;ways of working with the peripherals in Linux userspace - and their support on Raspberry Pi - are:</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> <h3><span style="font-family: Arial, Helvetica, sans-serif;">I2C/SMB</span></h3><div><span style="font-family: Arial, Helvetica, sans-serif;">Linux kernel has a driver for the I2C/SMBus: i2c-dev module. Access from userspace is through reads, writes and ioctls on&nbsp;<a href="http://www.kernel.org/doc/Documentation/i2c/dev-interface">/dev/i2c-n</a> files. Package&nbsp;<a href="http://www.lm-sensors.org/wiki/I2CTools">i2c-tools</a>&nbsp;contains userspace C bindings for I2C, a Python module (python-smb) and various command-line utilities.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
Hardware-specific bits for I2C on BCM2708 were <a href="https://github.com/raspberrypi/linux/blob/rpi-3.6.y/drivers/i2c/busses/i2c-bcm2708.c">written</a> by&nbsp;<a href="http://www.bootc.net/projects/raspberry-pi-kernel/">Chris Boot</a>&nbsp;&amp; <a href="https://github.com/FrankBuss/">Frank Buss</a> and are loaded by default on the&nbsp;<a href="http://learn.adafruit.com/adafruit-raspberry-pi-educational-linux-distro/occidentalis-v0-dot-2">Occidentalis</a>&nbsp;distribution from Adafruit that I use.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span></div><h3><span style="font-family: Arial, Helvetica, sans-serif;">SPI</span></h3><div><span style="font-family: Arial, Helvetica, sans-serif;">Linux kernel has a driver for the SPI bus: spidev module. Access from userspace is through reads, write and ioctls on <a href="http://www.kernel.org/doc/Documentation/spi/spidev">/dev/spidevB.C</a> files. Kernel documentation gives <a href="http://www.kernel.org/doc/Documentation/spi/spidev_test.c">examples</a> of use.&nbsp;</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
Hardware-specific bits for SPI on BCM2708 were <a href="https://github.com/raspberrypi/linux/blob/rpi-3.6.y/drivers/spi/spi-bcm2708.c">written</a> by&nbsp;<a href="http://www.bootc.net/projects/raspberry-pi-kernel/">Chris Boot</a>&nbsp;and are loaded by default on the&nbsp;<a href="http://learn.adafruit.com/adafruit-raspberry-pi-educational-linux-distro/occidentalis-v0-dot-2">Occidentalis</a>&nbsp;distribution.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span></div><h3><span style="font-family: Arial, Helvetica, sans-serif;">1-Wire</span></h3><div><div><span style="font-family: Arial, Helvetica, sans-serif;">Linux kernel has 1-Wire <a href="http://www.kernel.org/doc/Documentation/w1/">support</a>. Access from userspace is through sysfs files: /sys/bus/w1/... There is a module that implements 1-Wire on GPIO pins through bit-banging (w1-gpio).&nbsp;</span><span style="font-family: Arial, Helvetica, sans-serif;">Frank Buss</span><span style="font-family: Arial, Helvetica, sans-serif;">&nbsp;</span><a href="https://github.com/FrankBuss/linux-1/commit/71871509238d3e7bce4a74cdf616c3f12542acaa" style="font-family: Arial, Helvetica, sans-serif;">patched</a><span style="font-family: Arial, Helvetica, sans-serif;">&nbsp;</span><span style="font-family: Arial, Helvetica, sans-serif;">the Raspberry Pi kernel to</span><span style="font-family: Arial, Helvetica, sans-serif;">&nbsp;</span><a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?t=6649" style="font-family: Arial, Helvetica, sans-serif;">allow</a><span style="font-family: Arial, Helvetica, sans-serif;">&nbsp;</span><span style="font-family: Arial, Helvetica, sans-serif;">for a bit-banged implementation of 1-Wire. Occidentalis has this patch, but 1-Wire modules are not loaded by default.</span></div><br />
<span style="font-family: Arial, Helvetica, sans-serif;">If bit-banged 1-Wire turns out to be too computationally expensive, external I2C 1-Wire master like DS2482-100 can be used. There is a Linux module that supports it (ds2482).</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> <span style="font-family: Arial, Helvetica, sans-serif;">Alternatively, an external programmable device that implements 1-Wire in software can be used (for instance,&nbsp;<a href="http://www.teensypi.com/">TeensyPi</a>&nbsp;uses&nbsp;<a href="http://www.pjrc.com/teensy/">Teensy</a>&nbsp;board), but that looks like an overkill even to me :)</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span></span><span style="font-family: Arial, Helvetica, sans-serif;"><a href="http://owfs.org/">OWFS</a>&nbsp;- 1-Wire File System - is an open-source project that handles all kinds of 1-Wire stuff, including 1-Wire masters connected via I2C, and&nbsp;<a href="http://raspberrypi.homelabs.org.uk/i2c-connected-1-wire-masters/">works on Rasspbery Pi</a>.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> <h3><span style="font-family: Arial, Helvetica, sans-serif;">GPIO</span></h3></div><span style="font-family: Arial, Helvetica, sans-serif;">GPIO is supported in Linux through reads and writes of files in <a href="http://www.kernel.org/doc/Documentation/gpio.txt">/sys/class/gpio/</a>. This interface seems to support PWM and edge detection too. GPIO pins provided by external chips (like I2C expanders) should work the same way (if a driver for appropriate chip is loaded).</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> <span style="font-family: Arial, Helvetica, sans-serif;">A new&nbsp;<a href="https://github.com/torvalds/linux/blob/master/Documentation/pinctrl.txt">pinctrl</a>&nbsp;subsystem that supports pin functionality is being developed.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> This interface is suitable for use from shell, and is allegedly pretty slow, which is understandable: one has to read/write words like "on" from/to files... But I do not need to bit-bang on the GPIO pins if I have access to I2C; I only need to be able to detect a button press and blink a LED. The /sys/class/gpio interface is probably fast enough for that :)</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
In fact, kernel GPIO documentation says:&nbsp;</span><br />
<blockquote class="tr_bq"><span style="font-family: Arial, Helvetica, sans-serif;">Note that standard kernel drivers exist for common "LEDs and Buttons"GPIO tasks:  "leds-gpio" and "gpio_keys", respectively.  Use those instead of talking directly to the GPIOs; they integrate with kernel frameworks better than your userspace code could.</span></blockquote><span style="font-family: Arial, Helvetica, sans-serif;">I am not sure what the kernel can do with LEDs that I can not do from the userspace: blink them without software involvement? I do understand what the kernel can do for the buttons: handle them via interrupts instead of polling, and do de-bouncing. Maybe that is what gpio_keys module does?&nbsp;</span><span style="font-family: Arial, Helvetica, sans-serif;">Here is a tutorial on </span><a href="http://bec-systems.com/site/281/how-to-implement-an-interrupt-driven-gpio-input-in-linux" style="font-family: Arial, Helvetica, sans-serif;">detecting GPIO interrupts</a><span style="font-family: Arial, Helvetica, sans-serif;">&nbsp;in userspace. I am unclear on the gpio_keys support on Raspberry Pi.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span>   <br />
<pre style="white-space: pre-wrap; word-wrap: break-word;"></pre><span style="font-family: Arial, Helvetica, sans-serif;">The /sys/class/gpio interface does work on Raspberry Pi. Hardware-specific in <a href="https://github.com/raspberrypi/linux/blob/rpi-3.6.y/arch/arm/mach-bcm2708/bcm2708.c">bcm2708.c</a> and&nbsp;<a href="https://github.com/raspberrypi/linux/blob/rpi-3.6.y/arch/arm/mach-bcm2708/bcm2708_gpio.c">bcm2708_gpio.c</a>&nbsp;was written by Broadcom.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> <h3><span style="font-family: Arial, Helvetica, sans-serif;">UART</span></h3><div><span style="font-family: Arial, Helvetica, sans-serif;">Serial interfaces are represented as /dev/ttyX devices on Linux.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
Raspberry Pi UART appears as /dev/ttyAMA0 - after it is&nbsp;<a href="http://learn.adafruit.com/adafruit-nfc-rfid-on-raspberry-pi/freeing-uart-on-the-pi">freed</a>&nbsp;from other purposes (console?) it is dedicated to.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span></div><h2><span style="font-family: Arial, Helvetica, sans-serif;">Raspberry Pi Peripherals and Scala</span></h2></div><div><h3><span style="font-family: Arial, Helvetica, sans-serif;">I2C/SMB</span></h3></div><div><span style="font-family: Arial, Helvetica, sans-serif;">Peter Simon (rotok) <a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?p=187073#p187073">announced</a>&nbsp;a&nbsp;Java JNA&nbsp;<a href="http://simonp.uw.hu/linuxi2c/linuxi2c_java_v0_1.zip">binding</a> for Linux I2C on 10/3/2012. According to a comment on his announcement, it is the first Java I2C binding:</span><br />
<blockquote class="tr_bq"><span style="font-family: Arial, Helvetica, sans-serif;">"Thank you Peter! People have been looking for a Linux I2C Java binding for years and your code is the first publicly available binding, nice!".</span></blockquote><span style="font-family: Arial, Helvetica, sans-serif;">The binding uses native calls to open/close/read/write a file and for ioctl. Since there is a way to obtain a native file descriptor number from a file that was opened from Java (using sun.misc.SharedSecrets), only one (!) JNA call is really necessary: ioctl (one can hope that one of these years Java will get ioctl, and then no native calls will be needed). I did my own binding in Scala using this one native call.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
For completeness, I plan to expand coverage of my I2C binding beyond the basic functionality that I needed so far, using i2c-tools as a guide. (I may implement the command-line utilities from i2c-tools also.)</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
I used Adafruit Python <a href="https://github.com/adafruit/Adafruit-Raspberry-Pi-Python-Code.git">code</a>&nbsp;as a guide for the parts from Adafruit (like the 4 digit 7 segment display). For SHT21 that, <a href="http://forums.electricimp.com/discussion/comment/2280#Comment_2280">thanks to Hugo</a>, already worked with the Electric Imp, it was a straightforward translation.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
I plan to add coverage for more I2C parts, from Adafruit and otherwise, as I use them :)</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> <h3><span style="font-family: Arial, Helvetica, sans-serif;">GPIO</span></h3><span style="font-family: Arial, Helvetica, sans-serif;">There is a JNI binding for GPIO - <a href="http://pi4j.com/">pi4j</a>, developed by&nbsp;Robert Savage and Chris Walzl.&nbsp;I even tried to use it, but some JNI parts of it were missing in the Maven repository... At some point, the author invited Peter Simon to bring his I2C binding into the project, but I think that did not happen and they developed their own approach. I prefer not to use JNI.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
It may be possible to bind using JNA to BCM2835 library or <a href="https://projects.drogon.net/raspberry-pi/wiringpi/">WiringPi</a> library (the one pi4j binds to using JNI), but they are not a part of distribution, and I'd rather be more self-contained.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
There is a Java wrapper around /sys/class/gpio: <a href="https://github.com/jkransen/framboos">framboos</a>. It does not use JNI or JNA, relying on Linux-standard way of working with the GPIO through files. RPi.GPIO also used this approach originally, but switched to using I/O registers through /dev/mem, and claims that it is faster.&nbsp;For controlling LEDs and buttons, if&nbsp;leds-gpio and gpio_keys do not work out, I'll use framboos (or, more likely, a Scala binding inspired by it).</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
To make GPIO fast from Scala, without non-standard libraries or JNI, I need access to &nbsp;Raspberry Pi I/O registers. I may need it even if speed is not an issue, for alternative function select on the GPIO pins.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> <span style="font-family: Arial, Helvetica, sans-serif;">According to the documentation, peripherals are mammed into memory starting at physical address 0x20000000.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> <span style="font-family: Arial, Helvetica, sans-serif;">There are at least two ways of working with the arbitrary memory locations directly from Java (and Scala): com.sun.jna.Native or sun.misc.Unsafe (an instance of which has to be obtained using <a href="http://highlyscalable.wordpress.com/2012/02/02/direct-memory-access-in-java/">reflection</a>). Version of JNA that is currently on Raspberry Pi does not have the methods for direct memory access. Unsafe approach did not work for me: JVM crashes! This is, probably, because - as&nbsp;</span><span style="font-family: Arial, Helvetica, sans-serif;">Chris Hatton <a href="http://www.chrishatton.org/archives/88">notes</a>&nbsp;(</span><span style="font-family: Arial, Helvetica, sans-serif;">referring to the peripherals area of the memory as&nbsp;</span><span style="font-family: Arial, Helvetica, sans-serif;">&nbsp;the&nbsp;</span><span style="font-family: Arial, Helvetica, sans-serif;">"lower megabyte"</span><span style="font-family: Arial, Helvetica, sans-serif;">) -&nbsp;</span><span style="font-family: Arial, Helvetica, sans-serif;">the process has to give Linux some kind of a notice before accessing arbitrary memory locations.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> <span style="font-family: Arial, Helvetica, sans-serif;">This is probably why </span><span style="font-family: Arial, Helvetica, sans-serif;">RPi.GPIO, bcm2835 and WiringPi&nbsp;</span><span style="font-family: Arial, Helvetica, sans-serif;">libraries and the peripherals <a href="http://elinux.org/RPi_Low-level_peripherals#GPIO_Driving_Example_.28C.29">tutorial</a> use&nbsp;</span><span style="font-family: Arial, Helvetica, sans-serif;">memory-mapping an area of /dev/mem file to access&nbsp;</span><span style="font-family: Arial, Helvetica, sans-serif;">low-level peripherals through registers. Tutorial, following the code </span><a href="http://www.raspberrypi.org/forum/educational-applications/gertboard/page-4/#p31555" style="font-family: Arial, Helvetica, sans-serif;">provided</a><span style="font-family: Arial, Helvetica, sans-serif;"> by Gert van Loo and Dom, maps a block of desired size without pre-allocating anything;&nbsp;</span><span style="font-family: Arial, Helvetica, sans-serif;">bcm2835 also maps without pre-allocating memory, although there is a function for page-alligned allocation in the code (which is not called);&nbsp;</span><span style="font-family: Arial, Helvetica, sans-serif;">RPi.GPIO pre-allocates a buffer and mapps to that part of it that is page-alligned (using "fixed" mode) ; and so does WiringPi.</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> <span style="font-family: Arial, Helvetica, sans-serif;">There is a method to memory-map a file in pure Java: FileChannel.map(). Unfortunatelly, it does not work for /dev/mem, since its size is reported as 0, and Java's map() implementation attempts to "extend" the file, with comical results ;)</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> <span style="font-family: Arial, Helvetica, sans-serif;">It seems that calling mmap through JNA is necessary. So far all attempts on my part to make that work failed: the JVM crashes. It is now a challenge - to figure out a way to do this :)</span><br />
<span style="font-family: Arial, Helvetica, sans-serif;"><br />
</span> <h3><span style="font-family: Arial, Helvetica, sans-serif;">SPI and 1-Wire</span></h3><br />
<div><span style="font-family: Arial, Helvetica, sans-serif;">For completeness, I might do SPI and&nbsp;</span><span style="font-family: Arial, Helvetica, sans-serif;">1-Wire bindings.</span></div><div><br />
</div></div><div></div>